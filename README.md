# Compiler Design Project
## Lexical Analyzer and Syntax Analyzer Implementation

---

## 1. Project Overview

This project is part of the **Principles of Programming Languages** course. The objective is to design and implement a **Lexical Analyzer** and a **Syntax Analyzer** for a custom programming language, following formal compiler theory.

The implementation strictly follows the course requirements and emphasizes concepts from **Automata Theory** and **Sebesta-style language design**.

Key goals of the project:
- Implement a **pure Finite State Machine (FSM)** for lexical analysis
- Implement a **Recursive Descent Parser**, equivalent to a **Pushdown Automaton (PDA)**
- Clearly separate lexical analysis and syntax analysis

---

## 2. Lexical Analyzer (`FSM_lexical_analyzer.c`)

### 2.1 Purpose

The lexical analyzer reads raw source code and converts it into a sequence of **tokens**. These tokens are then passed to the syntax analyzer for structural validation.

---

### 2.2 Design Approach

- Implemented as a **pure Finite State Machine (FSM)**
- No recursion, no stack, and no grammar rules
- Each character transition is handled by explicit FSM states
- Token classification is based solely on state transitions

This implementation follows the definition of a **Deterministic Finite Automaton (DFA)**.

---

### 2.3 Token Output Format

Tokens are produced in the following format:
TOKEN_TYPE(token_value)


Example output:


KEYWORD(main)

RESERVED_WORD(int)

IDENTIFIER(a)

NUMBER(10)

REL_OP(==)

LOGICAL(and)

STRING(Hello World)

SEMICOLON(;)


---

### 2.4 Token Categories

The lexer recognizes the following token types:

- **KEYWORD**: `if`, `else`, `while`, `for`, `return`, `output`, `input`, `continue`, `break`, `main`
- **RESERVED_WORD**: `int`, `float`, `bool`, `char`, `str`, `void`, `True`, `False`, `null`
- **IDENTIFIER**
- **NUMBER**
- **STRING**
- **CHAR**
- **ARITH_OP** (`+ - * / %`)
- **REL_OP** (`< <= > >= == !=`)
- **LOGICAL** (`and`, `or`, `not`)
- **ASSIGN_OP** (`=`)
- **DELIMITERS** (`(` `)` `{` `}` `[` `]` `,` `;`)
- **NOISE_WORD** (`then`, `do`, `begin`, `end`)
- **NEW_LINE**

The lexer performs **no syntax or semantic validation**.

---

## 3. Syntax Analyzer (`syntax_analyzer.c`)

### 3.1 Purpose

The syntax analyzer verifies whether the sequence of tokens generated by the lexer conforms to the **grammar rules** of the language.

---

### 3.2 Parsing Technique

- Implemented using **Recursive Descent Parsing**
- Each grammar production is implemented as a C function
- Uses the function call stack as an implicit stack

This makes the syntax analyzer equivalent to a **Pushdown Automaton (PDA)**.

---

### 3.3 Pushdown Automaton Representation

The parser dynamically records transitions using:

logTransition(current_state, input_token, next_state);

---

## 4. Supported Language Constructs

The syntax analyzer supports the following language constructs as required by the course:

- **Input Statements**
- **Output Statements** (variable only, string only, string + variable)
- **Assignment Statements**
  - Variable to variable
  - Constant to variable
  - Expression to variable
- **Conditional Statements**
  - `if`
  - `if–else`
  - `if–else if`
- **Iterative Statements**
  - `while` loop
  - `for` loop (including nested loops)
- **Declaration Statements**
  - Single declaration: `int a;`
  - Multiple declaration: `int c, d, e;`
- **Function Definitions and Calls**
- **Block Statements**
  - `{ ... }`
  - `begin ... end`

---

## 5. Expression Parsing

Expressions are parsed using **recursive descent with operator precedence**, implemented through layered parsing functions:

- Logical OR (`or`)
- Logical AND (`and`)
- Logical NOT (`not`)
- Relational operators (`<`, `<=`, `>`, `>=`, `==`, `!=`)
- Arithmetic operators (`+`, `-`, `*`, `/`, `%`)
- Parenthesized expressions

This ensures correct precedence and associativity.

---

## 6. Error Handling and Recovery

### 6.1 Syntax Error Detection

The parser detects syntax errors such as:

- Missing semicolons
- Invalid statement starters
- Unmatched parentheses or braces
- Malformed declarations or control structures

---

### 6.2 Error Recovery Method

A **panic-mode error recovery** strategy is used.  
When an error is encountered, the parser skips tokens until it reaches a **synchronization point**, such as:

- `;` (end of statement)
- `}` (end of block)
- Start of a new valid statement (`if`, `for`, `while`, `return`, `output`, `input`)
- Type declarations (`int`, `float`, `bool`, `char`, `str`, `void`)
- `IDENTIFIER`

This prevents infinite loops and allows parsing to continue.

---

## 7. Scope Limitation

This project focuses **only on syntax analysis** as required by the course:

- No semantic analysis
- No type checking
- No runtime evaluation

All checks performed are structural only.

---

## 8. Theory Compliance Summary

| Component | Theory Model | Implementation |
|---------|-------------|----------------|
| Lexical Analyzer | DFA | Pure FSM |
| Syntax Analyzer | PDA | Recursive Descent |
| Stack | Pushdown Stack | Function Call Stack |
| Error Recovery | Panic Mode | `recover()` |

---

## 9. Conclusion

This project implements a complete compiler front-end consisting of a **pure FSM-based lexical analyzer** and a **recursive descent syntax analyzer equivalent to a pushdown automaton**. The design strictly follows compiler theory principles and satisfies the course requirements.




